// Copyright (C) 2022 Maxim Gumin, The MIT License (MIT)

using System.Linq;
using System.Xml.Linq;
using System.Collections.Generic;

/// <summary>
/// Represents a single rewrite rule, with an input pattern and an output
/// pattern. The input pattern may have wildcards and unions, which can match
/// multiple colors; the output pattern may have wildcards, which are not
/// written to the grid when the rule is applied.
/// </summary>
class Rule
{
    /// <summary>The width of the input pattern.</summary>
    public int IMX;

    /// <summary>The height of the input pattern.</summary>
    public int IMY;

    /// <summary>The depth of the input pattern. A 2D pattern has a depth of 1.</summary>
    public int IMZ;

    /// <summary>The width of the output pattern.</summary>
    public int OMX;

    /// <summary>The height of the output pattern.</summary>
    public int OMY;

    /// <summary>The depth of the output pattern. A 2D pattern has a depth of 1.</summary>
    public int OMZ;

    /// <summary>The input pattern, as a flat array of bitmasks.</summary>
    public int[] input;

    /// <summary>The output pattern, as a flat array. Wildcards are represented as <c>0xff</c>.</summary>
    public byte[] output;
    
    /// <summary>
    /// The input pattern, as a flat array. Wildcards are represented as
    /// <c>0xff</c>; unions are replaced with their lowest member.
    /// </summary>
    public byte[] binput;

    /// <summary>
    /// The probability that this rule will be applied. Only used by
    /// <see cref="ParallelNode">ParallelNode</see>.
    /// </summary>
    public double p;

    /// <summary>
    /// The offsets for each color in the input pattern. <c>ishifts[c]</c>
    /// contains (x, y, z) if and only if the color <c>c</c> matches at that
    /// position in the input pattern (allowing for wildcards and unions).
    /// </summary>
    public (int, int, int)[][] ishifts;

    /// <summary>
    /// The offsets for each color in the output pattern. <c>oshifts[c]</c>
    /// contains (x, y, z) if and only if the color <c>c</c> can occur at that
    /// position in the output pattern (allowing for wildcards).
    /// </summary>
    public (int, int, int)[][] oshifts;

    /// <summary>
    /// A rule is 'original' if it appears in the program's source code;
    /// otherwise, the rule was generated by symmetry and is not 'original'.
    /// </summary>
    public bool original;

    /// <param name="input"><inheritdoc cref="Rule.input" path="/summary"/></param>
    /// <param name="IMX"><inheritdoc cref="Rule.IMX" path="/summary"/></param>
    /// <param name="IMY"><inheritdoc cref="Rule.IMY" path="/summary"/></param>
    /// <param name="IMZ"><inheritdoc cref="Rule.IMZ" path="/summary"/></param>
    /// <param name="output"><inheritdoc cref="Rule.output" path="/summary"/></param>
    /// <param name="OMX"><inheritdoc cref="Rule.OMX" path="/summary"/></param>
    /// <param name="OMY"><inheritdoc cref="Rule.OMY" path="/summary"/></param>
    /// <param name="OMZ"><inheritdoc cref="Rule.OMZ" path="/summary"/></param>
    /// <param name="C"><inheritdoc cref="Grid.C" path="/summary"/></param>
    /// <param name="p"><inheritdoc cref="Rule.p" path="/summary"/></param>
    public Rule(int[] input, int IMX, int IMY, int IMZ, byte[] output, int OMX, int OMY, int OMZ, int C, double p)
    {
        this.input = input;
        this.output = output;
        this.IMX = IMX;
        this.IMY = IMY;
        this.IMZ = IMZ;
        this.OMX = OMX;
        this.OMY = OMY;
        this.OMZ = OMZ;

        this.p = p;

        // build ishifts array
        List<(int, int, int)>[] lists = new List<(int, int, int)>[C];
        for (int c = 0; c < C; c++) lists[c] = new List<(int, int, int)>();
        for (int z = 0; z < IMZ; z++) for (int y = 0; y < IMY; y++) for (int x = 0; x < IMX; x++)
                {
                    int w = input[x + y * IMX + z * IMX * IMY];
                    for (int c = 0; c < C; c++, w >>= 1) if ((w & 1) == 1) lists[c].Add((x, y, z));
                }
        ishifts = new (int, int, int)[C][];
        for (int c = 0; c < C; c++) ishifts[c] = lists[c].ToArray();

        // build oshifts array
        if (OMX == IMX && OMY == IMY && OMZ == IMZ)
        {
            for (int c = 0; c < C; c++) lists[c].Clear();
            for (int z = 0; z < OMZ; z++) for (int y = 0; y < OMY; y++) for (int x = 0; x < OMX; x++)
                    {
                        byte o = output[x + y * OMX + z * OMX * OMY];
                        if (o != 0xff) lists[o].Add((x, y, z));
                        else for (int c = 0; c < C; c++) lists[c].Add((x, y, z));
                    }
            oshifts = new (int, int, int)[C][];
            for (int c = 0; c < C; c++) oshifts[c] = lists[c].ToArray();
        }

        // build binput array
        int wildcard = (1 << C) - 1;
        binput = new byte[input.Length];
        for (int i = 0; i < input.Length; i++)
        {
            int w = input[i];
            binput[i] = w == wildcard ? (byte)0xff : Helper.FirstNonZeroPosition(w);
        }
    }

    /// <summary>
    /// Returns a new rule by rotating this one about the z axis.
    /// </summary>
    public Rule ZRotated()
    {
        int[] newinput = new int[input.Length];
        for (int z = 0; z < IMZ; z++) for (int y = 0; y < IMX; y++) for (int x = 0; x < IMY; x++)
                    newinput[x + y * IMY + z * IMX * IMY] = input[IMX - 1 - y + x * IMX + z * IMX * IMY];

        byte[] newoutput = new byte[output.Length];
        for (int z = 0; z < OMZ; z++) for (int y = 0; y < OMX; y++) for (int x = 0; x < OMY; x++)
                    newoutput[x + y * OMY + z * OMX * OMY] = output[OMX - 1 - y + x * OMX + z * OMX * OMY];

        return new Rule(newinput, IMY, IMX, IMZ, newoutput, OMY, OMX, OMZ, ishifts.Length, p);
    }

    /// <summary>
    /// Returns a new rule by rotating this one about the y axis.
    /// </summary>
    public Rule YRotated()
    {
        int[] newinput = new int[input.Length];
        for (int z = 0; z < IMX; z++) for (int y = 0; y < IMY; y++) for (int x = 0; x < IMZ; x++)
                    newinput[x + y * IMZ + z * IMZ * IMY] = input[IMX - 1 - z + y * IMX + x * IMX * IMY];

        byte[] newoutput = new byte[output.Length];
        for (int z = 0; z < OMX; z++) for (int y = 0; y < OMY; y++) for (int x = 0; x < OMZ; x++)
                    newoutput[x + y * OMZ + z * OMZ * OMY] = output[OMX - 1 - z + y * OMX + x * OMX * OMY];

        return new Rule(newinput, IMZ, IMY, IMX, newoutput, OMZ, OMY, OMX, ishifts.Length, p);
    }

    /// <summary>
    /// Returns a new rule by reflecting this one in the x axis.
    /// </summary>
    public Rule Reflected()
    {
        int[] newinput = new int[input.Length];
        for (int z = 0; z < IMZ; z++) for (int y = 0; y < IMY; y++) for (int x = 0; x < IMX; x++)
                    newinput[x + y * IMX + z * IMX * IMY] = input[IMX - 1 - x + y * IMX + z * IMX * IMY];

        byte[] newoutput = new byte[output.Length];
        for (int z = 0; z < OMZ; z++) for (int y = 0; y < OMY; y++) for (int x = 0; x < OMX; x++)
                    newoutput[x + y * OMX + z * OMX * OMY] = output[OMX - 1 - x + y * OMX + z * OMX * OMY];

        return new Rule(newinput, IMX, IMY, IMZ, newoutput, OMX, OMY, OMZ, ishifts.Length, p);
    }

    /// <summary>
    /// Determines whether two rules are equal by value.
    /// </summary>
    public static bool Same(Rule a1, Rule a2)
    {
        if (a1.IMX != a2.IMX || a1.IMY != a2.IMY || a1.IMZ != a2.IMZ || a1.OMX != a2.OMX || a1.OMY != a2.OMY || a1.OMZ != a2.OMZ) return false;
        for (int i = 0; i < a1.IMX * a1.IMY * a1.IMZ; i++) if (a1.input[i] != a2.input[i]) return false;
        for (int i = 0; i < a1.OMX * a1.OMY * a1.OMZ; i++) if (a1.output[i] != a2.output[i]) return false;
        return true;
    }

    /// <summary>
    /// Returns an enumerable of symmetric counterparts of this rule.
    /// </summary>
    /// <param name="symmetry">An array of flags defining a subgroup of symmetries.</param>
    /// <param name="d2">If <c>true</c>, only 2D symmetries are generated; otherwise, 3D symmetries are generated.</param>
    public IEnumerable<Rule> Symmetries(bool[] symmetry, bool d2)
    {
        if (d2) return SymmetryHelper.SquareSymmetries(this, r => r.ZRotated(), r => r.Reflected(), Same, symmetry);
        else return SymmetryHelper.CubeSymmetries(this, r => r.ZRotated(), r => r.YRotated(), r => r.Reflected(), Same, symmetry);
    }

    public static (char[] data, int MX, int MY, int MZ) LoadResource(string filename, string legend, bool d2)
    {
        if (legend == null)
        {
            Interpreter.WriteLine($"no legend for {filename}");
            return (null, -1, -1, -1);
        }
        (int[] data, int MX, int MY, int MZ) = d2 ? Graphics.LoadBitmap(filename) : VoxHelper.LoadVox(filename);
        if (data == null)
        {
            Interpreter.WriteLine($"couldn't read {filename}");
            return (null, MX, MY, MZ);
        }
        (byte[] ords, int amount) = data.Ords();
        if (amount > legend.Length)
        {
            Interpreter.WriteLine($"the amount of colors {amount} in {filename} is more than {legend.Length}");
            return (null, MX, MY, MZ);
        }
        return (ords.Select(o => legend[o]).ToArray(), MX, MY, MZ);
    }

    /// <summary>
    /// Parses a pattern from a string, returning a flat array of characters,
    /// and the pattern's width, height and depth. If the pattern cannot be
    /// parsed, then <c>(null, -1, -1, -1)</c> is returned.
    /// </summary>
    static (char[], int, int, int) Parse(string s)
    {
        string[][] lines = Helper.Split(s, ' ', '/');
        int MX = lines[0][0].Length;
        int MY = lines[0].Length;
        int MZ = lines.Length;
        char[] result = new char[MX * MY * MZ];

        for (int z = 0; z < MZ; z++)
        {
            string[] linesz = lines[MZ - 1 - z];
            if (linesz.Length != MY)
            {
                Interpreter.Write("non-rectangular pattern");
                return (null, -1, -1, -1);
            }
            for (int y = 0; y < MY; y++)
            {
                string lineszy = linesz[y];
                if (lineszy.Length != MX)
                {
                    Interpreter.Write("non-rectangular pattern");
                    return (null, -1, -1, -1);
                }
                for (int x = 0; x < MX; x++) result[x + y * MX + z * MX * MY] = lineszy[x];
            }
        }
        
        return (result, MX, MY, MZ);
    }
    
    /// <summary>
    /// Loads a rewrite rule from an XML element. The loading may fail if the
    /// XML data is invalid, or a referenced resource file cannot be loaded, in
    /// which case <c>null</c> is returned.
    /// </summary>
    /// <param name="xelem">The XML element.</param>
    /// <param name="gin">The grid which the input pattern will be matched against.</param>
    /// <param name="gout">The grid which the output pattern will be written to. This is usually the same as <c>gin</c>.</param>
    public static Rule Load(XElement xelem, Grid gin, Grid gout)
    {
        int lineNumber = xelem.LineNumber();
        string filepath(string name)
        {
            string result = "resources/rules/";
            if (gout.folder != null) result += gout.folder + "/";
            result += name;
            result += gin.MZ == 1 ? ".png" : ".vox";
            return result;
        };

        string inString = xelem.Get<string>("in", null);
        string outString = xelem.Get<string>("out", null);
        string finString = xelem.Get<string>("fin", null);
        string foutString = xelem.Get<string>("fout", null);
        string fileString = xelem.Get<string>("file", null);
        string legend = xelem.Get<string>("legend", null);

        char[] inRect, outRect;
        int IMX = -1, IMY = -1, IMZ = -1, OMX = -1, OMY = -1, OMZ = -1;
        if (fileString == null)
        {
            if (inString == null && finString == null)
            {
                Interpreter.WriteLine($"no input in a rule at line {lineNumber}");
                return null;
            }
            if (outString == null && foutString == null)
            {
                Interpreter.WriteLine($"no output in a rule at line {lineNumber}");
                return null;
            }

            (inRect, IMX, IMY, IMZ) = inString != null ? Parse(inString) : LoadResource(filepath(finString), legend, gin.MZ == 1);
            if (inRect == null)
            {
                Interpreter.WriteLine($" in input at line {lineNumber}");
                return null;
            }

            (outRect, OMX, OMY, OMZ) = outString != null ? Parse(outString) : LoadResource(filepath(foutString), legend, gin.MZ == 1);
            if (outRect == null)
            {
                Interpreter.WriteLine($" in output at line {lineNumber}");
                return null;
            }

            if (gin == gout && (OMZ != IMZ || OMY != IMY || OMX != IMX))
            {
                Interpreter.WriteLine($"non-matching pattern sizes at line {lineNumber}");
                return null;
            }
        }
        else
        {
            if (inString != null || finString != null || outString != null || foutString != null)
            {
                Interpreter.WriteLine($"rule at line {lineNumber} already contains a file attribute");
                return null;
            }
            (char[] rect, int FX, int FY, int FZ) = LoadResource(filepath(fileString), legend, gin.MZ == 1);
            if (rect == null)
            {
                Interpreter.WriteLine($" in a rule at line {lineNumber}");
                return null;
            }
            if (FX % 2 != 0)
            {
                Interpreter.WriteLine($"odd width {FX} in {fileString}");
                return null;
            }
            
            IMX = OMX = FX / 2;
            IMY = OMY = FY;
            IMZ = OMZ = FZ;

            inRect = AH.FlatArray3D(FX / 2, FY, FZ, (x, y, z) => rect[x + y * FX + z * FX * FY]);
            outRect = AH.FlatArray3D(FX / 2, FY, FZ, (x, y, z) => rect[x + FX / 2 + y * FX + z * FX * FY]);
        }

        int[] input = new int[inRect.Length];
        for (int i = 0; i < inRect.Length; i++)
        {
            char c = inRect[i];
            bool success = gin.waves.TryGetValue(c, out int value);
            if (!success)
            {
                Interpreter.WriteLine($"input code {c} at line {lineNumber} is not found in codes");
                return null;
            }
            input[i] = value;
        }

        byte[] output = new byte[outRect.Length];
        for (int o = 0; o < outRect.Length; o++)
        {
            char c = outRect[o];
            if (c == '*') output[o] = 0xff;
            else
            {
                bool success = gout.values.TryGetValue(c, out byte value);
                if (!success)
                {
                    Interpreter.WriteLine($"output code {c} at line {lineNumber} is not found in codes");
                    return null;
                }
                output[o] = value;
            }
        }

        double p = xelem.Get("p", 1.0);
        return new Rule(input, IMX, IMY, IMZ, output, OMX, OMY, OMZ, gin.C, p);
    }
}
